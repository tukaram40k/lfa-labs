# Lab 5 Report: Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Author: Ivan Rudenco

----

## Theory:
Context-Free Grammars (CFGs) are formal grammars used to generate context-free languages. They consist of variables (non-terminal symbols), terminals (symbols that appear in the language), productions (rules for replacing variables), and a start symbol. The Chomsky Normal Form (CNF) is a simplified form of context-free grammars where all production rules have either the form A → BC (where B and C are non-terminals) or A → a (where a is a terminal). Converting a CFG to CNF is essential for various parsing algorithms, such as the CYK algorithm, which efficiently determines whether a string can be generated by a given grammar. This transformation preserves the language generated by the original grammar while standardizing its structure for easier processing.

## Objectives:
1. Learn about Chomsky Normal Form (CNF).

2. Get familiar with the approaches of normalizing a grammar.
3. Implement a method for normalizing an input grammar by the rules of CNF.
    1. The implementation needs to be encapsulated in a method with an appropriate signature (also ideally in an appropriate class/type).
    2. The implemented functionality needs executed and tested.
    3. Also, another **BONUS point** would be given if the student will make the aforementioned function to accept any grammar, not only the one from the student's variant.


## Implementation description

The implementation consists of a ToCNF class that performs the conversion of a context-free grammar to Chomsky Normal Form through a series of systematic transformations. The class is initialized with the non-terminal symbols (`vn`), terminal symbols (`vt`), production rules (`p`), and start symbol (`s`).

In order to have multiple options for new `vn`s, I anned a long list of free characters to serve as potential variables.

```py
en_ch = [chr(i) for i in range(ord('A'), ord('Z') + 1)]
ru_ch = [chr(i) for i in range(ord('А'), ord('Я') + 1)]
for ch in ['А', 'В', 'С', 'Е', 'К', 'Н', 'Р', 'О', 'Т', 'М', 'У', 'Х']:
    if ch in ru_ch:
        ru_ch.remove(ch)
cn_ch = [chr(i) for i in range(int('0x4E00', 16) + 500, int('0x9FFF', 16) + 1)]
self.free_chars = en_ch + ru_ch + cn_ch
```

### 1. Removal of start symbol from the right side

The first transformation makes sure that the start symbol doesn't appear on the right side of any production rule:

```py
for vn, rules in self.p.items():
    for rule in rules:
        if self.s in rule:
            new_s = self.next_free_ch()
            self.p[new_s] = [self.s]
            self.s = new_s
            self.vn.append(new_s)
            return
```

### 2. Removal of null productions

Chains of symbols leading to epsilon are removed, and new production rules are added.

```py
while changed:
    changed = False
    for A in self.p:
        if A not in nullable:
            for rule in self.p[A]:
                if rule == 'epsilon' or all(symbol in nullable for symbol in rule):
                    nullable.add(A)
                    changed = True
                    break
```

### 3. Removal of unit productions

Symbols that produce a single non-terminal are replaced by new production rules for other symbols.

```py
unit_pairs = {vn: set() for vn in self.vn}

    for A in self.vn:
        for rule in self.p[A]:
            if len(rule) == 1 and rule in self.vn:
                unit_pairs[A].add(rule)
```

### 4. Removal of extra variables

Production rules with more than two variables on the right side are broken into smaller ones by introducing new variables.

```py
productions = list(self.p.items())
for A, rules in productions:
    new_rules = []
    for rule in rules:
        if len(rule) <= 2:
            new_rules.append(rule)
```

### 5. Removing mixed up Vn and Vt

Production rules with both terminals and non-terminals on the right side are replaced with additional variables.

```py
term_to_var = {}
    for terminal in self.vt:
        if terminal not in term_to_var:
            new_var = self.next_free_ch()
            term_to_var[terminal] = new_var
            self.vn.append(new_var)
            self.p[new_var] = [terminal]
```

After all steps are done, obtained CNF can be printed to console:

```py
def __str__(self):
    return f'Vn = {self.vn}\n\nVt = {self.vt}\nS = {self.s}\n\nP = {self.p}\n'
```

## Conclusions / Screenshots / Results

The results of converting CFG to CNF:

```
Vn = ['S', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'Б', 'Г', 'Д', 'Ж', 'З', 'И', 'Й', 'Л', 'П', 'Ф', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь']

Vt = ['a', 'b']

S = 'E'

P = {'S': ['BC', 'ЬN', 'ЬL', 'ЬJ', 'ЫS', 'ЬA', 'ЬS', 'a', 'ЬG', 'ЬF'], 'A': ['ЫS', 'ЬO', 'a', 'ЬR', 'ЬW', 'ЬU'], 'B': ['ЫS', 'ЬA', 'ЬS', 'a', 'ЬY', 'ЬЖ', 'ЬГ', 'ЬИ', 'ЬX'], 'C': ['AB'], 'D': ['AB'], 'E': ['BC', 'ЬЙ', 'ЫS', 'ЬA', 'ЬЦ', 'ЬЪ', 'ЬS', 'ЬЛ', 'a', 'ЬШ'], 'F': ['CA'], 'G': ['CH'], 'H': ['ЫI'], 'I': ['CЫ'], 'J': ['ЫK'], 'K': ['CЫ'], 'L': ['CM'], 'M': ['ЫЫ'], 'N': ['ЫЫ'], 'O': ['CP'], 'P': ['ЫQ'], 'Q': ['CЫ'], 'R': ['ЫT'], 'T': ['CЫ'], 'U': ['CV'], 'V': ['ЫЫ'], 'W': ['ЫЫ'], 'X': ['CA'], 'Y': ['CZ'], 'Z': ['ЫБ'], 'Б': ['CЫ'], 'Г': ['ЫД'], 'Д': ['CЫ'], 'Ж': ['CЗ'], 'З': ['ЫЫ'], 'И': ['ЫЫ'], 'Й': ['CA'], 'Л': ['CП'], 'П': ['ЫФ'], 'Ф': ['CЫ'], 'Ц': ['ЫЧ'], 'Ч': ['CЫ'], 'Ш': ['CЩ'], 'Щ': ['ЫЫ'], 'Ъ': ['ЫЫ'], 'Ы': ['a'], 'Ь': ['b']}
```

The implementation of the Chomsky Normal Form conversion algorithm demonstrates the systematic approach to transforming context-free grammars. Each step addresses a specific aspect of the transformation, ensuring that the resulting grammar adheres to the CNF restrictions while preserving the language generated by the original grammar.
The use of different character sets to manage new variable names is a creative solution to avoid conflicts, especially when dealing with complex grammars that might require many new variables. The algorithm also handles various edge cases, such as nullable variables and unit productions, with careful attention to maintaining the language's integrity.
Overall, this implementation provides a robust foundation for CFG transformations, which is essential for applications in parsing and formal language theory.

## References
- [amazing Indian tutorials](https://www.youtube.com/watch?v=FNPSlnj3Vt0)
- [good ol' friend](https://chatgpt.com/)